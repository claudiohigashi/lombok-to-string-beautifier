package com.github.claudiohigashi.lombok.beautifier;

/**
 * <h>Lombok toString() beautifier</h>
 *
 * <p>
 * This utility class takes as input a String generated by the Lombok's @ToString
 * and generates a more beautiful String by placing each field in a separate line
 * and also providing a proper indentation.
 * </p>
 *
 * @author Claudio Higashi
 */
public class LombokToStringBeautifier {
    public static String beautify(String toString) {
        Context ctx = new Context(toString);
        beautify(ctx);
        return ctx.stringBuilder.toString();
    }

    private static void beautify(Context ctx) {
        while (true) {
            writeAWord(ctx);
            if (ctx.isEndOfChars()) {
                break;
            }

            ctx.appendChar();
            if (ctx.isOneOf("([")) {
                ctx.level++;
                ctx.newLineAndIdent();
            } else if (ctx.isOneOf(")]")) {
                ctx.level--;
                if (ctx.index + 1 < ctx.chars.length && ctx.chars[ctx.index + 1] != ',') {
                    ctx.newLineAndIdent();
                }
            } else if (ctx.isCurrentChar(',')) {
                ctx.newLineAndIdent();
            }
            ctx.index++;
        }
    }

    private static void writeAWord(Context ctx) {
        // skip spaces in the beginning
        while (ctx.isNotEndOfChars() && ctx.isCurrentChar(' ')) {
            ctx.index++;
        }

        // write the word
        while (!ctx.isEndOfChars() && !ctx.isOneOf("()[],=")) {
            ctx.appendChar();
            ctx.index++;
        }
    }

    private static class Context {
        int index;
        int level;
        char[] chars;
        StringBuilder stringBuilder;

        Context(String toString) {
            this.chars = toString.toCharArray();
            this.stringBuilder = new StringBuilder();
        }

        void appendChar() {
            stringBuilder.append(chars[index]);
        }

        boolean isNotEndOfChars() {
            return index < chars.length;
        }

        boolean isEndOfChars() {
            return index >= chars.length;
        }

        boolean isOneOf(String string) {
            return index < chars.length && string.indexOf(chars[index]) != -1;
        }

        boolean isCurrentChar(char c) {
            return index < chars.length && chars[index] == c;
        }

        void newLineAndIdent() {
            stringBuilder.append('\n');
            for (int i = 0; i < level; i++) {
                stringBuilder.append("    ");
            }
        }
    }
}
